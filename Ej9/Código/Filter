from matplotlib import pyplot as p
import math

class Filter:

    def __init__(self, alfa, betha):
        self.alfa = alfa
        self.betha = betha
        # wsq : discriminant of the cuadratic function that will determine the type of system
        self.w_sq = alfa**2 + 4*betha
        self.oscillates = self.w_sq < 0

        self.osc_freq = 0
        if self.oscillates:
            self.osc_freq = (-self.w_sq)**(1/2)

        self.coef_x = 0.5

        self.last_out = [0, 0]           # set initial conditions, y[-2], y[-1]
        self.y = []

    # in_sequence should start with x(n = -1) !!!!
    def in_out(self, in_sequence):
        self.y = [self.last_out[0], self.last_out[1]]

        for i in range(len(in_sequence)):
            self.y.append(in_sequence[i]*self.coef_x + self.alfa * self.y[i+1] + self.betha * self.y[i])

        self.y = self.y[2:len(self.y)]
        self.last_out[0] = self.y[len(self.y)-1]
        self.last_out[1] = self.y[len(self.y)-2]

        return self.y

        # use after calling in_out(in_sequence) to retrieve a value from the lastly calculated in_out
    def in_out_last_calc(self, n):
        return self.y[n]

    def set_initial_conditions(self, conditions):
        if (conditions is None) or (range(conditions) != 2):
            print("Error en las condiciones inciales. Se necesitan 2 condiciones iniciales.")
        else:
            self.last_out[0] = conditions[0]
            self.last_out[1] = conditions[1]

    def set_null_initial_conditions(self):
        self.last_out[0] = 0
        self.last_out[1] = 0


f1 = Filter(1, -1/2)
# f2 = Filter(1/3, -1/8)
# f3 = Filter(4/3, -25/32)
f1.set_null_initial_conditions()
n = list(range(4000))

f0 = [i*0.01 for i in range(100000)]
T = 0.001

H = [(1 / (2 + 0.8*math.cos(math.pi*2*f0[i])))**(1/2) for i in range(len(f0))]
p.plot(f0, H)
p.show()
print("hola")